use std::{collections::HashSet, path::Path};

use sqlx::{types::chrono::Utc, PgConnection};
use tokio::fs;

use crate::{
    models::{Payload, UpdatePath},
    util::{extension_versions, update_paths},
};

pub async fn add(
    payload: &Payload,
    output_path: &Path,
    mut conn: PgConnection,
) -> anyhow::Result<()> {
    let existing_versions = extension_versions(&mut conn, &payload.metadata.extension_name).await?;
    let mut installed_extension_once = !existing_versions.is_empty();
    let mut versions_installed_now = HashSet::new();

    let timestamp = Utc::now().format("%Y%m%d%H%M%S");
    let mut migration_content = String::new();

    // Header with metadata
    migration_content.push_str("-- Migration generated by dbdev add at: ");
    migration_content.push_str(&Utc::now().format("%Y-%m-%d %H:%M:%S").to_string());
    migration_content.push('\n');

    migration_content.push_str("-- Extension: ");
    migration_content.push_str(&payload.metadata.extension_name);
    migration_content.push('\n');

    migration_content.push_str("-- Default version: ");
    migration_content.push_str(&payload.metadata.default_version);
    migration_content.push('\n');

    if let Some(comment) = &payload.metadata.comment {
        migration_content.push_str("-- Comment: ");
        migration_content.push_str(comment);
        migration_content.push('\n');
    }

    // Add prerequisites first
    if !&payload.metadata.requires.is_empty() {
        migration_content.push_str("-- Install prerequisites\n");
        for req in &payload.metadata.requires {
            migration_content.push_str("CREATE EXTENSION IF NOT EXISTS ");
            migration_content.push_str(req);
            migration_content.push_str(";\n");
        }
        migration_content.push('\n');
    }

    for install_file in &payload.install_files {
        if !existing_versions.contains(&install_file.version) {
            if installed_extension_once {
                // For subsequent versions
                migration_content.push_str("-- Installing version ");
                migration_content.push_str(&install_file.version);
                migration_content.push('\n');

                migration_content.push_str("SELECT pgtle.install_extension_version_sql('");
                migration_content.push_str(&payload.metadata.extension_name);
                migration_content.push_str("', '");
                migration_content.push_str(&install_file.version);
                migration_content.push_str("', $SQL$");
                migration_content.push_str(&install_file.body);
                migration_content.push_str("$SQL$);\n\n");

                versions_installed_now.insert(install_file.version.clone());
            } else {
                // For initial installation
                migration_content.push_str("-- Initial installation of version: ");
                migration_content.push_str(&install_file.version);
                migration_content.push('\n');

                let requirements = payload
                    .metadata
                    .requires
                    .iter()
                    .map(|r| format!("'{}'", r))
                    .collect::<Vec<_>>()
                    .join(",");

                migration_content.push_str("SELECT pgtle.install_extension('");
                migration_content.push_str(&payload.metadata.extension_name);
                migration_content.push_str("', '");
                migration_content.push_str(&install_file.version);
                migration_content.push_str("', $COMMENT$");
                migration_content.push_str(payload.metadata.comment.as_deref().unwrap_or(""));
                migration_content.push_str("$COMMENT$, $SQL$");
                migration_content.push_str(&install_file.body);
                migration_content.push_str("$SQL$, ARRAY[");
                migration_content.push_str(&requirements);
                migration_content.push_str("]::text[] );\n\n");

                versions_installed_now.insert(install_file.version.clone());
                installed_extension_once = true;
            }
        }
    }

    let existing_update_paths =
        (update_paths(&mut conn, &payload.metadata.extension_name).await).unwrap_or_default();

    for upgrade_file in &payload.upgrade_files {
        let update_path = UpdatePath {
            source: upgrade_file.from_version.clone(),
            target: upgrade_file.to_version.clone(),
        };
        if !existing_update_paths.contains(&update_path) {
            migration_content.push_str("SELECT pgtle.install_update_path('");
            migration_content.push_str(&payload.metadata.extension_name);
            migration_content.push_str("', '");
            migration_content.push_str(&upgrade_file.from_version);
            migration_content.push_str("', '");
            migration_content.push_str(&upgrade_file.to_version);
            migration_content.push_str("', $SQL$");
            migration_content.push_str(&upgrade_file.body);
            migration_content.push_str("$SQL$);\n\n");
        }
    }

    // Create the extension
    migration_content.push_str("-- Create the extension\n");
    match &payload.metadata.schema {
        Some(schema) => {
            migration_content.push_str("CREATE EXTENSION IF NOT EXISTS ");
            migration_content.push_str(&payload.metadata.extension_name);
            migration_content.push_str(" SCHEMA ");
            migration_content.push_str(schema);
            migration_content.push_str(";\n");
        }
        None => {
            migration_content.push_str("CREATE EXTENSION IF NOT EXISTS ");
            migration_content.push_str(&payload.metadata.extension_name);
            migration_content.push_str(";\n");
        }
    }

    // Set default version
    migration_content.push_str("-- Setting default version to:");
    migration_content.push_str(&payload.metadata.default_version);
    migration_content.push('\n');

    migration_content.push_str("SELECT pgtle.set_default_version('");
    migration_content.push_str(&payload.metadata.extension_name);
    migration_content.push_str("', '");
    migration_content.push_str(&payload.metadata.default_version);
    migration_content.push_str("');\n");

    // Write to file
    let mut filename = String::new();
    filename.push_str(&timestamp.to_string());
    filename.push('_');
    filename.push_str(&payload.metadata.extension_name);
    filename.push_str("_install.sql");

    let file_path = output_path.join(filename);

    fs::write(&file_path, migration_content).await?;

    println!("Generated migration file at: {}", file_path.display());
    Ok(())
}
