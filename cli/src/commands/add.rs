use std::{
    collections::HashSet,
    io::{BufWriter, Write},
    path::Path,
};

use sqlx::{types::chrono::Utc, PgConnection};
use tempfile::tempdir;
use tokio::fs;

use crate::{
    client::{ApiClient, GetLatestPackageVersionResponse},
    models::{Payload, UpdatePath},
    util::{create_file, extension_versions, update_paths},
};

pub async fn payload_from_package(
    client: ApiClient<'_>,
    package_name: &str,
) -> anyhow::Result<Payload> {
    let package_dir = tempdir()?;
    let package_dir_path = package_dir.path();

    let response = client.get_latest_package_version(package_name).await?;
    if response.len() != 1 {
        return Err(anyhow::anyhow!(
            "Invalid number of package versions returned: {}",
            response.len()
        ));
    }
    let response = &response[0];

    write_control_file(package_dir_path, response).await?;
    write_sql_file(package_dir_path, response).await?;

    let payload = Payload::from_path(package_dir_path)?;
    Ok(payload)
}

fn get_partial_name(package_name: &str) -> anyhow::Result<&str> {
    Ok(if let Some(index) = package_name.find('@') {
        &package_name[index + 1..]
    } else if let Some(index) = package_name.find('-') {
        &package_name[index + 1..]
    } else {
        return Err(anyhow::anyhow!("Invalid package name: {package_name}"));
    })
}

async fn write_control_file(
    package_dir_path: &Path,
    package: &GetLatestPackageVersionResponse,
) -> anyhow::Result<()> {
    let partial_name = get_partial_name(&package.package_name)?;
    let file_name = format!("{partial_name}.control");
    let file_path = package_dir_path.join(file_name);
    let file = create_file(&file_path)?;
    let mut writer = BufWriter::new(file);

    writeln!(writer, "# {partial_name} extension")?;
    writeln!(writer, "comment = '{}'", package.control_description)?;
    writeln!(writer, "default_version = '{}'", package.version)?;
    writeln!(writer, "superuser = false")?;

    if !package.control_requires.is_empty() {
        let requires = package.control_requires.join(", ");
        writeln!(writer, "requires = {requires}")?;
    }

    Ok(())
}

async fn write_sql_file(
    package_dir_path: &Path,
    package: &GetLatestPackageVersionResponse,
) -> anyhow::Result<()> {
    let partial_name = get_partial_name(&package.package_name)?;
    let file_name = format!("{partial_name}--{}.sql", package.version);
    let file_path = package_dir_path.join(file_name);
    let file = create_file(&file_path)?;
    let mut writer = BufWriter::new(file);

    write!(writer, "{}", package.sql)?;

    Ok(())
}

pub async fn add(
    payload: &Payload,
    output_path: &Path,
    mut conn: PgConnection,
) -> anyhow::Result<()> {
    let existing_versions = extension_versions(&mut conn, &payload.metadata.extension_name).await?;
    let mut installed_extension_once = !existing_versions.is_empty();
    let mut versions_installed_now = HashSet::new();

    let timestamp = Utc::now().format("%Y%m%d%H%M%S");
    let mut migration_content = String::new();

    // Header with metadata
    migration_content.push_str("-- Migration generated by dbdev add at: ");
    migration_content.push_str(&Utc::now().format("%Y-%m-%d %H:%M:%S").to_string());
    migration_content.push('\n');

    migration_content.push_str("-- Extension: ");
    migration_content.push_str(&payload.metadata.extension_name);
    migration_content.push('\n');

    migration_content.push_str("-- Default version: ");
    migration_content.push_str(&payload.metadata.default_version);
    migration_content.push('\n');

    if let Some(comment) = &payload.metadata.comment {
        migration_content.push_str("-- Comment: ");
        migration_content.push_str(comment);
        migration_content.push('\n');
    }

    // Add prerequisites first
    if !&payload.metadata.requires.is_empty() {
        migration_content.push_str("-- Install prerequisites\n");
        for req in &payload.metadata.requires {
            migration_content.push_str("CREATE EXTENSION IF NOT EXISTS ");
            migration_content.push_str(req);
            migration_content.push_str(";\n");
        }
        migration_content.push('\n');
    }

    for install_file in &payload.install_files {
        if !existing_versions.contains(&install_file.version) {
            if installed_extension_once {
                // For subsequent versions
                migration_content.push_str("-- Installing version ");
                migration_content.push_str(&install_file.version);
                migration_content.push('\n');

                migration_content.push_str("SELECT pgtle.install_extension_version_sql('");
                migration_content.push_str(&payload.metadata.extension_name);
                migration_content.push_str("', '");
                migration_content.push_str(&install_file.version);
                migration_content.push_str("', $SQL$");
                migration_content.push_str(&install_file.body);
                migration_content.push_str("$SQL$);\n\n");

                versions_installed_now.insert(install_file.version.clone());
            } else {
                // For initial installation
                migration_content.push_str("-- Initial installation of version: ");
                migration_content.push_str(&install_file.version);
                migration_content.push('\n');

                let requirements = payload
                    .metadata
                    .requires
                    .iter()
                    .map(|r| format!("'{r}'"))
                    .collect::<Vec<_>>()
                    .join(",");

                migration_content.push_str("SELECT pgtle.install_extension('");
                migration_content.push_str(&payload.metadata.extension_name);
                migration_content.push_str("', '");
                migration_content.push_str(&install_file.version);
                migration_content.push_str("', $COMMENT$");
                migration_content.push_str(payload.metadata.comment.as_deref().unwrap_or(""));
                migration_content.push_str("$COMMENT$, $SQL$");
                migration_content.push_str(&install_file.body);
                migration_content.push_str("$SQL$, ARRAY[");
                migration_content.push_str(&requirements);
                migration_content.push_str("]::text[] );\n\n");

                versions_installed_now.insert(install_file.version.clone());
                installed_extension_once = true;
            }
        }
    }

    let existing_update_paths =
        (update_paths(&mut conn, &payload.metadata.extension_name).await).unwrap_or_default();

    for upgrade_file in &payload.upgrade_files {
        let update_path = UpdatePath {
            source: upgrade_file.from_version.clone(),
            target: upgrade_file.to_version.clone(),
        };
        if !existing_update_paths.contains(&update_path) {
            migration_content.push_str("SELECT pgtle.install_update_path('");
            migration_content.push_str(&payload.metadata.extension_name);
            migration_content.push_str("', '");
            migration_content.push_str(&upgrade_file.from_version);
            migration_content.push_str("', '");
            migration_content.push_str(&upgrade_file.to_version);
            migration_content.push_str("', $SQL$");
            migration_content.push_str(&upgrade_file.body);
            migration_content.push_str("$SQL$);\n\n");
        }
    }

    // Create the extension
    migration_content.push_str("-- Create the extension\n");
    match &payload.metadata.schema {
        Some(schema) => {
            migration_content.push_str("CREATE EXTENSION IF NOT EXISTS ");
            migration_content.push_str(&payload.metadata.extension_name);
            migration_content.push_str(" SCHEMA ");
            migration_content.push_str(schema);
            migration_content.push_str(";\n");
        }
        None => {
            migration_content.push_str("CREATE EXTENSION IF NOT EXISTS ");
            migration_content.push_str(&payload.metadata.extension_name);
            migration_content.push_str(";\n");
        }
    }

    // Set default version
    migration_content.push_str("-- Setting default version to:");
    migration_content.push_str(&payload.metadata.default_version);
    migration_content.push('\n');

    migration_content.push_str("SELECT pgtle.set_default_version('");
    migration_content.push_str(&payload.metadata.extension_name);
    migration_content.push_str("', '");
    migration_content.push_str(&payload.metadata.default_version);
    migration_content.push_str("');\n");

    // Write to file
    let mut filename = String::new();
    filename.push_str(&timestamp.to_string());
    filename.push('_');
    filename.push_str(&payload.metadata.extension_name);
    filename.push_str("_install.sql");

    let file_path = output_path.join(filename);

    fs::write(&file_path, migration_content).await?;

    println!("Generated migration file at: {}", file_path.display());
    Ok(())
}
